class public auto ansi ExprOptimizer

method public Expr checkVarAs(var stm as Expr, var b as boolean&)
var tok as Token = stm::Tokens[0]
var typ as System.Type = gettype VarTok
valinref|b = typ::IsInstanceOfType($object$tok)
var vars as VarExpr = new VarExpr()

if valinref|b = true then
vars::Tokens = stm::Tokens
vars::Line = stm::Line
vars::VarName = stm::Tokens[1]

var tok2 as Token = stm::Tokens[3]
var typ2 as System.Type = gettype TypeTok
var b2 as boolean = typ2::IsInstanceOfType($object$tok2)

if b2 <> true then
var t as Token = stm::Tokens[3]
var tt as TypeTok = new TypeTok()
tt::Line = t::Line
tt::Value = t::Value
vars::VarTyp = tt
else
vars::VarTyp = stm::Tokens[3]
end if

end if
return vars
end method

method public MethodNameTok IdentToMNTok(var idt as Ident, var mnt as MethodNameTok)

mnt::DoNeg = idt::DoNeg
mnt::DoNot = idt::DoNot
mnt::Conv = idt::Conv
mnt::IsArr = idt::IsArr
mnt::ArrLoc = idt::ArrLoc
mnt::IsRef = idt::IsRef
mnt::IsValInRef = idt::IsValInRef
mnt::IsRefInst = idt::IsRefInst
mnt::IsValInRefInst = idt::IsValInRefInst
mnt::TTok = idt::TTok
mnt::OrdOp = idt::OrdOp
mnt::Value = idt::Value
mnt::Line = idt::Line

return mnt
end method

method public Expr procMethodCall(var stm as Expr, var i as integer)

var mn as MethodNameTok = new MethodNameTok()
var mct as MethodCallTok = new MethodCallTok()
var idt as Ident = null
var ep2 as Expr = new Expr()
var lvl as integer = 1
var d as boolean = true
var j as integer = 0

i--
idt = stm::Tokens[i]
mn = IdentToMNTok(idt, mn)
j = i
i++

var tok2 as Token = stm::Tokens[i]
var typ2 as System.Type
var b2 as boolean
var len as integer = stm::Tokens[l] - 1

stm::RemToken(i)
len = stm::Tokens[l] - 1
i--

label loop2
label cont2
label fin

place loop2

//get parameters
i++

tok2 = stm::Tokens[i]
typ2 = gettype RParen
b2 = typ2::IsInstanceOfType($object$tok2)
if b2 = true then
lvl--
if lvl = 0 then
d = false
mct::AddParam(ep2)
stm::RemToken(i)
len = stm::Tokens[l] - 1
i--
goto cont2
else
d = true
goto fin
end if
goto fin
end if

tok2 = stm::Tokens[i]
typ2 = gettype LParen
b2 = typ2::IsInstanceOfType($object$tok2)
if b2 = true then
lvl++
d = true
//stm::RemToken(i)
len = stm::Tokens[l] - 1
//i--
goto fin
end if

tok2 = stm::Tokens[i]
typ2 = gettype Comma
b2 = typ2::IsInstanceOfType($object$tok2)
if b2 = true then
if lvl = 1 then
d = false
mct::AddParam(ep2)
ep2 = new Expr()
stm::RemToken(i)
len = stm::Tokens[l] - 1
i--
goto fin
else
d = true
goto fin
end if
else
d = true
goto fin
end if

place fin

if d = true then
ep2::AddToken(stm::Tokens[i])
stm::RemToken(i)
len = stm::Tokens[l] - 1
i--
end if

if i = len then
goto cont2
else
goto loop2
end if

place cont2

mct::Name = mn
stm::Tokens[j] = mct

return stm

end method

method public Expr Optimize(var exp as Expr)

var len as integer = exp::Tokens[l] - 1
var i as integer = -1
var j as integer = -1

label loop
label cont


if len < 0 then
goto cont
end if

place loop

i++

label fin

var tok as Token = exp::Tokens[i]
var typ as System.Type
var b as boolean
var str as string

typ = gettype DollarSign
b = typ::IsInstanceOfType($object$tok)

if b = true then
ParserFlags::DurConvFlag = ParserFlags::DurConvFlag nor ParserFlags::DurConvFlag
ParserFlags::isChanged = true
if ParserFlags::DurConvFlag <> false then
ParserFlags::ConvFlag = true
ParserFlags::OrdOp = String::Concat("conv ", ParserFlags::OrdOp)
str = ParserFlags::OrdOp
str = str::Trim()
ParserFlags::OrdOp = str
end if
exp::RemToken(i)
i--
len = exp::Tokens[l] - 1
goto fin
end if

typ = gettype TypeTok
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::DurConvFlag <> false then
var tt1 as TypeTok = exp::Tokens[i]
ParserFlags::ConvTyp = tt1
exp::RemToken(i)
i--
len = exp::Tokens[l] - 1
end if
goto fin
end if

typ = gettype Ident
b = typ::IsInstanceOfType($object$tok)

if b = true then
ParserFlags::IdentFlag = true
if ParserFlags::isChanged = true then
var id1 as Ident = exp::Tokens[i]
exp::Tokens[i] = ParserFlags::UpdateIdent(id1)
ParserFlags::SetUnaryFalse()
j = i
end if
goto fin
end if

typ = gettype CharLiteral
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::isChanged = true then
var cl1 as CharLiteral = exp::Tokens[i]
exp::Tokens[i] = ParserFlags::UpdateCharLit(cl1)
ParserFlags::SetUnaryFalse()
j = i
end if
goto fin
end if

typ = gettype StringLiteral
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::isChanged = true then
var sl1 as StringLiteral = exp::Tokens[i]
exp::Tokens[i] = ParserFlags::UpdateStringLit(sl1)
ParserFlags::SetUnaryFalse()
j = i
end if
goto fin
end if

typ = gettype BooleanLiteral
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::isChanged = true then
var bl1 as BooleanLiteral = exp::Tokens[i]
exp::Tokens[i] = ParserFlags::UpdateBoolLit(bl1)
ParserFlags::SetUnaryFalse()
j = i
end if
goto fin
end if

typ = gettype NumberLiteral
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::isChanged = true then
var nl1 as NumberLiteral = exp::Tokens[i]
exp::Tokens[i] = ParserFlags::UpdateNumLit(nl1)
ParserFlags::SetUnaryFalse()
j = i
end if
goto fin
end if

typ = gettype LParen
b = typ::IsInstanceOfType($object$tok)

if b = true then
if ParserFlags::IdentFlag = true then
exp = procMethodCall(exp, i)
i--
len = exp::Tokens[l] - 1

var mct as MethodCallTok = exp::Tokens[i]
var prs as Expr[] = mct::Params
var ln2 as integer = prs[l] - 1

var i2 as integer = -1
label loop2
label cont2

if ln2 < 0 then
goto cont2
end if

place loop2
i2++
prs[i2] = Optimize(prs[i2])

if i2 = ln2 then
goto cont2
else
goto loop2
end if

place cont2

end if
goto fin
end if

if i > j then
ParserFlags::IdentFlag = false
end if

place fin

if i = len then
goto cont
else
goto loop
end if

place cont

return exp
end method

end class